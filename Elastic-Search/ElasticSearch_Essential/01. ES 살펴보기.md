# es 살펴보기
## es 특징
* 준실시간에 가깝게 빠르다. (refresh-interval : 1초, 색인한지 1초뒤부터 검색 가능)
* 고가용성을 위한 클러스터 구성
  * 한 대 이상의 노드로 클러스터 구성하여 높은 수준의 안정성 달성하고 부하 분산 가능
* 동적 스키마 생성
  * 입력될 데이터들에 대해 미리 스키마를 정의하지 않아도 동적으로 스키마 생성이 가능
  * rdb는 미리 스키마를 생성해야 되지만 es는 미리 정의하지 않아도 동적으로 만들어서 색인 할 수 있다.
* rest api 기반의 인터페이스 제공
  * 사용을 위한 진입 장벽 낮다.

## 클러스터와 노드
```
클러스터는 여러 대의 컴퓨터들이 연결되어 하나의 시스템처럼 동작하는 컴퓨터들의 집합
```  

es도 여러 대의 노드들이 각자의 역할을 바탕으로 연결되어 하나의 시스템처럼 동작  => 어떤 노드에 어떤 요청을 해도 동일한 응답을 준다.   

클러스터의 성능이 부족하면 노드를 늘려서 대응  

노드를 늘린다고 모두 성능을 늘릴 수 있는건 아니다. -> 추후 설명  


### 노드의 종류
* 마스터 노드 : 클러스터 상태 관리 및 메타데이터 관리
* 데이터 노드 : 문서 색인 및 검색 요청 처리
* 코디네이팅 노드 : 검색 요청 처리(따로 서버를 띄우는 경우)
* 인제스트 노드 : 색인되는 문서의 데이터 전처리

### 마스터 노드
1. 마스터 노드: 지금 클러스터에서 마스터 노드의 역할을 하고 있는 노드(무조건 1대)
2. 마스터 후보 노드: 마스터 노드에 문제가 생겼을 때 마스터 노드가 될 수 있는 노드

마스터 노드가 죽으면 마스터 후보 노드들 중에서 새로운 마스터가 된다.  


### es 클러스터 특징
어떤 노드에 어떤 요청을 해도 동일한 응답을 한다.


* client->마스터 노드->데이터노드->마스터노드->client. 
* client->데이터노드->client
* client->코디네이팅->데이터->코디네이팅->client

<img width="918" alt="스크린샷 2024-05-29 오후 5 33 11" src="https://github.com/shmin7777/ELK-study/assets/67637716/3e4b04f5-973a-4190-a380-20852adbc103">


!! 각각의 노드가 본연의 역할에 충실할 수 있도록 구성하는 것이 중요.  
이상적인 클러스터 아키텍처  
<img width="1042" alt="스크린샷 2024-05-29 오후 5 33 50" src="https://github.com/shmin7777/ELK-study/assets/67637716/29cdb145-9a94-4555-a7bf-7c24389b44f1">  


로드밸런서에 대한 검색과 색인 end-point를 만들어서 사용하는것이 좋다.  


## 인덱스와 샤드
![스크린샷 2024-05-29 오후 5 34 54](https://github.com/shmin7777/ELK-study/assets/67637716/d773eb1c-09c1-427b-a586-44fa480d1d46)  

인덱스: 문서가 저장되는 논리적인 공간, 문서를 저장하기 위해서는 반드시 인덱스가 존재해야함.  

인덱스를 설계하는것이 es를 사용하기 위해 고려해야 하는 첫 단계.  

### 인덱스 설계
<img width="1093" alt="스크린샷 2024-05-29 오후 5 35 35" src="https://github.com/shmin7777/ELK-study/assets/67637716/82aa8282-54cf-4a21-9c05-b635ec53813e">  

하나의 인덱스로 단순하게 시작 -> 사용 패턴(성능개선 등)에 따라 인덱스를 별도로 운영  

### 샤드
인덱스에 색인되는 문서가 저장되는공간, 하나의 인덱스는 반드시 하나 이상의 샤드를 가진다.  
<img width="1035" alt="스크린샷 2024-05-29 오후 5 35 52" src="https://github.com/shmin7777/ELK-study/assets/67637716/ea018c7b-ffdc-4117-bac0-f6f4f96946b4">  

* 프라이머리 샤드: 문서가 저장되는 원본 샤드, 색인과 검색 성능에 모두 영향을 줌
* 레플리카 샤드: 
 * 프라이머리 샤드의 복제 샤드, 검색 성능에 영향을 줌
 * 프라이머리 샤드에 문제가 생기면 레플리카 샤드가 프라이머리 샤드로 승격

색인과정은 프라이머리 샤드로 document가 들어오고 프라이머리샤드에서 분석(토크나이징 등)이 일어나고 레플리카 샤드로 복제되는 전과정을 의미.  
분석과정이 cpu를 많이 잡아먹기 때문에 레플리카샤드보다는 프라이머리 샤드의 개수가 더 중요함.  

### 샤드 설정
```
put /library/_settings
{
 "index": {
    "number_of_shards": 3,
    "number_of_replicas": 1
  }
}
```  

프라이머리 샤드는 3개, 레플리카 샤드도 3개(shards * replicas), 인덱스의 총 샤드 개수는 6개.  

### 샤드 라우팅
어떤 샤드에 문서가 들어갈 건지 라우팅룰.  
<img width="1110" alt="스크린샷 2024-05-29 오후 5 36 52" src="https://github.com/shmin7777/ELK-study/assets/67637716/02da9d19-7eab-4aeb-8a9b-76f9e08f63e4">  

중간에 샤드의 개수가 다이나믹하게 바뀐다면 라우팅 룰이 완전히 뒤바뀌기 때문에 인덱스에 프라이머리 샤드를 만들고 나서 샤드의 개수를 변경할 수 없다.!!  

따라서 인덱스를 생성할 때 프라이머리 샤드의 수를 정하는건 매우 중요하다.  

number_of_shards의 기본값은 1이다.  
이 기본값을 그대로 사용하면 성능에 큰 영향을 미친다.  

### 인덱스 템플릿
인덱스 생성 이후 샤드 개수를 변경할 수 없기 떄문에, 인덱스 템플릿을 통해 인덱스 생성 시의 샤드 개수를 미리 설정할 수 있다.  

``` 
PUT /index_template/base_template
{
  "index_patterns": ["nginx-logs-*"],
  "template": {
    "settings": {
     "number_of_shards": 3,
     "number_of_replicas": 2
    }
  }
}

```  

nginx-logs-* 로 시작하는 모든 인덱스는 프라이머리 샤드 3개, 레플리카 샤드 6개로 생성.  
ex> nginx-logs-2022.11.01, nginx-logs-2022.11.02 ...  


## 매핑(mapping)
문서의 구조를 나타내는 정보, es는 스키마리스가 아니라 미리 정의하지 않아도 될 뿐.  
매핑 정보가 생성된 후에는 타입이 안맞을 경우 파싱 에러가 발생.  

* 동적 매핑(Dynamic Mapping): 처음 색인되는 문서를 바탕으로 매핑 정보를 es가 동적으로 생성
* 정적 매핑(Static Mapping): 문서의 매핑 정보를 미리 정의

### 동적 매핑
<img width="1096" alt="스크린샷 2024-05-29 오후 5 37 17" src="https://github.com/shmin7777/ELK-study/assets/67637716/f2be125b-0cec-4a94-90d0-f4cd310e489a">  

### 정적 매핑
<img width="1154" alt="스크린샷 2024-05-29 오후 5 37 24" src="https://github.com/shmin7777/ELK-study/assets/67637716/33f9d162-87f5-4af4-bfd8-fe2a7757f757">  

type, author는 여기서 동적 매핑이 된다.  

* 정적 매핑은 언제 도움이 될까?  
 * 문서의 필드들이가지는 값에 따라 타입을 지정해 줄 필요가 있을 때.  
 * 불필요한 색인이 발생하지 않게 하기 위해.(ex> 문자열 필드 마다 자동 생성되는 keyword 타입)


